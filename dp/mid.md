数组dp的思路最一般的思路是：假设长度为n-1个元素的数组，现在多出了第n个元素，那么f(n)都与哪些f(i)有关。

如果没办法直观的看出与哪些f(i)有关，可以想想利用f(i) + 更加复杂的算法来计算f(n)。难点在于更加复杂的算法如何思考了。

下面例题给出了一个方向，可以将数组拆分成两个部分，在所有拆分中，找到最优解。这种思想可以作为以后思考dp的一个方向。

这种拆分自然地引入了两维变量i和j，[i, j]限定了数组的部分范围。二维dp也就出来了。

此时
```
f(0, n) = g(f(0, mid), f(mid + 1, n)); 
// 下题中g是遍历求最小值。
```

如上表达式，如何进行计算呢？画矩阵可以发现，f(i, j) = f(i, mid) + f(mid + 1, j)，其中(i, mid)是(i, j)左边的点，(mid + 1, j) 是(i, j) 下边的点，所以只要从下到上，从左到右计算就可以了。
```
for (int i = arr.size() - 1; i >= 0; i--) { // 从下到上
    for (int j = i; j < arr.size(); j++) { // 从左到右
        if (i == j) {
            xxx
        } else {
            for (int k = i; k < j; k++) { // k作为分隔点

            }
        }
    }
}
```

```
1130. 叶值的最小代价生成树

给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：

每个节点都有 0 个或是 2 个子节点。
数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。
每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。
在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。

如果一个节点有 0 个子节点，那么该节点为叶节点。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

