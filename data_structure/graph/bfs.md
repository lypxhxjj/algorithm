无权重的最短路径问题，使用bfs解决。

bfs如何写代码，参考层序遍历，使用队列的方式。

最短路径需要知晓路径内节点个数（表现为需要知晓最短路径的路径长度，或者层序遍历中的第几层），bfs遍历过程中有两种方式解决：
1. 遍历队列使用while + for循环的方式遍历；
2. 使用两个队列 + swap的方式遍历；

图与树的一个区别在于，图需要考虑环的问题，即需要一个visited数组。这里visited数组怎么使用呢？
1. 正确的：第一次拿到节点的时候设置，表现为入队前；dfs前；
2. 不太好的：Visit(node)时设置，即从队列中拿出来之后判断有没有visit过，平白多了一次入队过程。

矩阵如何转化为图的问题，一个节点到其他节点，四个方向、八个方向，快速遍历的代码如下：
```
// 4个方向，一重循环。
int xDelta[] = {-1, 0, 0, 1};
int yDelta[] = {0, 1, -1, 0}; // 即x和y的偏移中，每次有一个偏移为0，另外一个偏移不为0
for (int i = 0; i < 4; i++) {
    Visit({x + xDelta[i], y + yDelta[i]});
}

// 8个方向，二重循环。
for (int i = -1; i <= 1; i++) { // i代表x的偏移
    for (int j = -1; j <= 1; j++) { // j代表y的偏移。
        Visit({x + i, y + j}); 
    }
}
```

广度优先搜索 + visited数组的方式的时间复杂度是多少？o(n ^ 2)，因为最差，全部互相相连。

例题：
1091. 二进制矩阵中的最短路径 https://leetcode.cn/problems/shortest-path-in-binary-matrix/